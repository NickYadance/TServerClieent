#include "client.h"

using namespace std;

extern  TsConf TS_CONF ;

const char TsConf::KEY_AUTH[33] = "yzmond:id*str&to!tongji@by#Auth^";
const char TsConf::LOG_PATH[] = "./";
const char TsConf::CONF_PATH[] = "./ts.conf" ;
const char TsConf::CONFIG_PATH[] = "./config.dat" ;
const char TsConf::PRO_PATH[] = "./process.dat" ;
const char TsConf::USB_PATH[] = "./usbfiles.dat" ;
const char TsConf::COUNT_PATH[] = "./ts_count.xls" ;

void    TsConf::init()
{
    /***********default value**********/
    strcpy(IP, "10.60.102.252");
    PORT        = 52335;
    PERCENT     = 95;
    EXIT        = 1;
    MIN_DEV_NUM = 5;
    MAX_DEV_NUM = 28;
    MIN_TTY_NUM = 3;
    MAX_TTY_NUM = 10;
    DEL_LOG     = 1;
    PRINT_DEBUG_INFO = 1;
    TIME_GAP = 5;
    strcpy(DEBUG, "11111");
    /*********************/

    ifstream conf(CONF_PATH);
    if (!conf.is_open())
    {
        if (DEBUG[1] == '1')
        {
            cout << "fatal error:config file lost!"<<endl;
        }
        exit(-1);
    }

    char  word[50];
    while(conf >> word)
    {
        if (!strcmp(word, "服务器IP地址"))
        {
            conf >> IP;
        }
        else if (!strcmp(word, "端口号"))
        {
            conf >> PORT;
        }
        else if (!strcmp(word, "网点百分比"))
        {
            conf >> PERCENT;

        }
        else if (!strcmp(word, "进程接收成功后退出"))
        {
            conf >> EXIT;
        }
        else if (!strcmp(word, "最小配置终端数量"))
        {
            conf >> MIN_DEV_NUM;
        }
        else if (!strcmp(word, "最大配置终端数量"))
        {
            conf >> MAX_DEV_NUM;
        }
        else if (!strcmp(word, "每个终端最小虚屏数量"))
        {
            conf >> MIN_TTY_NUM;
        }
        else if (!strcmp(word, "每个终端最大虚屏数量"))
        {
            conf >> MAX_TTY_NUM;
        }
        else if (!strcmp(word, "删除日志文件"))
        {
            conf >> DEL_LOG;
        }
        else if (!strcmp(word, "DEBUG设置"))
        {
            conf >> DEBUG;
        }
        else if (!strcmp(word, "DEBUG屏幕显示"))
        {
            conf >> PRINT_DEBUG_INFO;
        }
        memset(word, 0, strlen(word));
    }
    conf.close();

    ofstream    xlscount;
    xlscount.open(TsConf::COUNT_PATH);
    xlscount.close();
}

u_char secret[4096]={
    0x8b, 0xd6, 0xee, 0xeb, 0x1b, 0x60, 0xbb, 0xf3, 0xbe, 0xa1, 0x31, 0xe7, 0xd9, 0x92, 0x2d, 0x88,
    0x22, 0xab, 0x2b, 0x0a, 0x40, 0x48, 0x16, 0xe8, 0x4f, 0x6b, 0x7e, 0x6e, 0x6b, 0xad, 0x9c, 0xf6,
    0x83, 0x8a, 0xe1, 0x9f, 0xea, 0x9c, 0x92, 0xa8, 0x3d, 0xc3, 0x8f, 0x16, 0x55, 0xbd, 0x9e, 0x77,
    0x68, 0xc9, 0x82, 0xa8, 0x12, 0x98, 0x91, 0x61, 0x03, 0x0f, 0xd0, 0x6e, 0xbd, 0x6c, 0x64, 0x40,
    0xf6, 0x45, 0xdf, 0xe0, 0xe1, 0x71, 0x89, 0x1e, 0x34, 0x18, 0x35, 0x89, 0xd5, 0xd3, 0x01, 0x3e,
    0x9d, 0x83, 0xe6, 0xaf, 0x1b, 0x77, 0x10, 0x1e, 0x87, 0xe0, 0x8d, 0x44, 0x4c, 0xf1, 0x84, 0x42,
    0x37, 0x64, 0x23, 0x18, 0xd5, 0xac, 0x37, 0x0a, 0xc4, 0x6c, 0x93, 0x9a, 0x3f, 0x94, 0xd8, 0xdc,
    0x17, 0xbe, 0x8b, 0x32, 0x36, 0x9c, 0x51, 0xbd, 0x7c, 0xde, 0x01, 0xc9, 0xcf, 0x85, 0x0b, 0x06,
    0xe9, 0x2e, 0x1f, 0xbf, 0xda, 0x56, 0xc9, 0x9f, 0xc2, 0x5c, 0x39, 0x01, 0xf1, 0x11, 0xde, 0x08,
    0xcf, 0x69, 0x3b, 0x05, 0x05, 0x8c, 0xc2, 0x82, 0x6a, 0xc3, 0x4b, 0x39, 0x49, 0x56, 0x40, 0x32,
    0x85, 0x5f, 0xf1, 0x5f, 0xb5, 0xba, 0xfe, 0x77, 0x17, 0x37, 0x78, 0x08, 0x48, 0x56, 0x10, 0x18,
    0xc0, 0x4b, 0x1d, 0xc5, 0xd7, 0xe0, 0x47, 0x41, 0xa3, 0x92, 0x7b, 0xec, 0xe9, 0xbb, 0x1f, 0x6e,
    0x1a, 0x10, 0xcd, 0xcf, 0xcb, 0xcc, 0x46, 0xe2, 0x03, 0xbe, 0xea, 0x4c, 0x15, 0xfa, 0x64, 0xd5,
    0x46, 0x81, 0x9a, 0x1d, 0x61, 0xe2, 0x5f, 0x05, 0x74, 0xda, 0xf1, 0x5d, 0x95, 0x10, 0xcb, 0xaf,
    0x21, 0x99, 0x7e, 0xec, 0x65, 0xc4, 0xce, 0x68, 0x82, 0xb8, 0xb4, 0x97, 0xb2, 0x18, 0x6c, 0xf8,
    0x9a, 0x07, 0x16, 0xfb, 0xe9, 0x75, 0x00, 0x5d, 0x4f, 0xf2, 0xbb, 0xe4, 0x02, 0x86, 0x93, 0x23,
    0x1f, 0x11, 0x0f, 0x84, 0xd5, 0xdd, 0xed, 0x57, 0x95, 0xa1, 0xef, 0x48, 0xba, 0x5b, 0x40, 0x54,
    0x62, 0x56, 0x4f, 0x4b, 0xcb, 0x50, 0xa9, 0x1a, 0x42, 0x64, 0xfe, 0x44, 0xea, 0x91, 0x68, 0x0a,
    0xa2, 0x77, 0x8e, 0x77, 0x55, 0x7b, 0xcf, 0xea, 0x1d, 0xbe, 0x32, 0xd7, 0x19, 0x73, 0x2b, 0x7c,
    0xc9, 0x7a, 0xc7, 0x95, 0xca, 0x70, 0xaf, 0x0c, 0xd4, 0xae, 0x51, 0xbf, 0x3f, 0xb9, 0xc9, 0xe2,
    0x30, 0x57, 0x59, 0x85, 0xd3, 0x28, 0x70, 0xf0, 0xe6, 0xa2, 0xc7, 0x00, 0x15, 0xf2, 0x7c, 0xdf,
    0x6c, 0x43, 0x74, 0x37, 0xb4, 0x23, 0x43, 0x88, 0xd1, 0x94, 0x47, 0x11, 0x4d, 0x10, 0xf3, 0x7e,
    0x68, 0x4c, 0x03, 0x3b, 0x75, 0x73, 0x2b, 0x5b, 0x16, 0xf2, 0x5b, 0x2b, 0xe4, 0xd7, 0x0a, 0x50,
    0x1b, 0x7e, 0x87, 0xcf, 0xa2, 0xcb, 0x57, 0x73, 0x5f, 0x9f, 0x84, 0xad, 0xaf, 0x77, 0x2b, 0x17,
    0xc4, 0x2e, 0x52, 0x39, 0xa2, 0x7d, 0x94, 0xb8, 0x6f, 0xf0, 0xe3, 0x53, 0xc7, 0xee, 0xa4, 0xe2,
    0x6c, 0x2b, 0xb1, 0x0e, 0xf6, 0x09, 0x82, 0x56, 0xa8, 0x06, 0x03, 0x57, 0x7e, 0x2e, 0x6f, 0x42,
    0x5c, 0xc1, 0x7b, 0xfe, 0x3f, 0x0f, 0xb6, 0xae, 0xff, 0x9a, 0x02, 0xc7, 0x88, 0xa6, 0xa9, 0xf4,
    0xd1, 0x5b, 0x03, 0xc8, 0x64, 0x85, 0x1e, 0x0c, 0x8b, 0x21, 0x63, 0x09, 0x4f, 0xd2, 0x4b, 0xab,
    0x94, 0xc6, 0xaa, 0xd3, 0xd6, 0x60, 0x81, 0xd5, 0xfa, 0x83, 0x9c, 0x82, 0x29, 0x46, 0x77, 0xfb,
    0xa1, 0x7a, 0xc3, 0x05, 0xff, 0xe1, 0x11, 0x8a, 0x02, 0x74, 0x94, 0x51, 0x47, 0xdf, 0xfc, 0xdb,
    0xa6, 0xa6, 0xae, 0x7c, 0x07, 0x2f, 0x51, 0x01, 0xb3, 0xee, 0x84, 0xdc, 0x34, 0xfb, 0xd7, 0xd5,
    0x75, 0x9a, 0xda, 0x74, 0x7b, 0xeb, 0xfe, 0x7d, 0x5f, 0x92, 0xce, 0xa6, 0x72, 0xcb, 0x81, 0x18,
    0x71, 0x2f, 0x94, 0x78, 0x5f, 0xe5, 0x7a, 0x12, 0xd3, 0xfe, 0xee, 0x07, 0xf9, 0xc6, 0xdc, 0x6e,
    0x60, 0xb6, 0xe2, 0xdc, 0xa1, 0xe0, 0x59, 0x01, 0x73, 0x28, 0xa7, 0xe5, 0xf3, 0x29, 0xfd, 0x64,
    0x58, 0x91, 0xdd, 0xb7, 0x76, 0x57, 0xc9, 0x4a, 0x55, 0xb8, 0x51, 0x4e, 0x7e, 0x2e, 0xbc, 0xde,
    0xe4, 0x9e, 0xba, 0x86, 0x7e, 0x14, 0x87, 0xf1, 0x3c, 0x2e, 0xd6, 0x2f, 0x57, 0xd3, 0x93, 0xb0,
    0x64, 0x70, 0x67, 0xdb, 0xc7, 0x31, 0x25, 0x1c, 0xe9, 0x76, 0x6a, 0x67, 0xa4, 0x26, 0x45, 0x89,
    0xc4, 0x00, 0x0f, 0x43, 0x14, 0x96, 0x34, 0x50, 0xc4, 0x0b, 0x7f, 0x1c, 0xde, 0x12, 0xcc, 0x43,
    0x83, 0x33, 0x1e, 0x4a, 0x64, 0x43, 0x67, 0x4d, 0xb9, 0xd1, 0xb4, 0x5e, 0xf8, 0xfa, 0xe7, 0xbc,
    0xfa, 0xf6, 0xff, 0x0e, 0x8c, 0x34, 0x5e, 0x50, 0x3f, 0xdd, 0x6c, 0x1d, 0xef, 0x38, 0x60, 0x72,
    0x6c, 0x7e, 0xbd, 0xd0, 0xc1, 0x24, 0x1e, 0x7b, 0xf5, 0xd2, 0xd9, 0xed, 0xcc, 0xc0, 0xaa, 0xc6,
    0xb6, 0xa9, 0xd4, 0x42, 0xdd, 0x32, 0x92, 0x1c, 0x0f, 0xff, 0x3a, 0xff, 0x37, 0x9a, 0x71, 0xa3,
    0x19, 0x2e, 0x74, 0xda, 0x52, 0x92, 0x55, 0x48, 0x64, 0x2e, 0x35, 0x31, 0xee, 0xdf, 0xf7, 0xa4,
    0x89, 0xcc, 0xe6, 0x66, 0xfe, 0x79, 0x83, 0x0e, 0x78, 0xbd, 0x0d, 0xaf, 0x57, 0x7e, 0x53, 0x70,
    0xad, 0xc7, 0x4b, 0xff, 0x59, 0xa0, 0x47, 0xbd, 0xcf, 0x7d, 0xee, 0xbd, 0x5c, 0xe6, 0x62, 0xe5,
    0xb2, 0x48, 0x4c, 0xb0, 0xc1, 0xcf, 0xbe, 0x39, 0x8c, 0xcb, 0xe9, 0xe3, 0x4a, 0x3c, 0x54, 0xf7,
    0x03, 0x9f, 0xf6, 0x5c, 0x3f, 0x3e, 0x19, 0x0e, 0xbb, 0x08, 0xcc, 0x17, 0xee, 0x2e, 0xfd, 0xa0,
    0x76, 0x49, 0x50, 0x38, 0x18, 0x0f, 0x71, 0xa4, 0xda, 0x5a, 0x87, 0x24, 0x96, 0xdb, 0x1b, 0x99,
    0x7a, 0x12, 0xf5, 0xba, 0x50, 0x0f, 0xc8, 0x0b, 0x17, 0x94, 0x22, 0x05, 0xc2, 0x1f, 0xa5, 0x39,
    0x68, 0xf5, 0x71, 0x80, 0x04, 0xe2, 0x24, 0xdf, 0x3d, 0xac, 0x03, 0xd3, 0x87, 0x1f, 0x6d, 0x02,
    0x31, 0x62, 0xbc, 0x81, 0x71, 0x84, 0x8c, 0x88, 0x19, 0xae, 0x8d, 0xdb, 0xce, 0x32, 0x14, 0x36,
    0x28, 0x85, 0xb7, 0x2c, 0x68, 0xdb, 0x0b, 0xa5, 0x87, 0x0f, 0x78, 0x0f, 0x2e, 0xe5, 0x11, 0x5f,
    0x48, 0xcd, 0xe0, 0xb9, 0x51, 0x6c, 0x42, 0x6a, 0x1a, 0xcf, 0x46, 0xe8, 0x02, 0x5a, 0x1f, 0x2a,
    0xe0, 0xd6, 0x56, 0x48, 0xb1, 0x62, 0xed, 0x39, 0x71, 0x65, 0x48, 0x9f, 0x4b, 0x59, 0xfe, 0x93,
    0x26, 0xde, 0x4c, 0x77, 0x4a, 0x8e, 0xe2, 0x64, 0x5e, 0x28, 0x4d, 0x60, 0x82, 0x6c, 0x8a, 0x62,
    0x42, 0xe0, 0xaa, 0xf3, 0x42, 0x97, 0x2c, 0xb3, 0xfd, 0x74, 0x52, 0x48, 0xcd, 0x50, 0xdb, 0xf3,
    0x2e, 0x27, 0x6b, 0x78, 0xb6, 0x4d, 0xdd, 0x14, 0x75, 0x2a, 0x74, 0xf7, 0x96, 0xfe, 0x5a, 0xd8,
    0xde, 0x04, 0xcb, 0x21, 0x9c, 0xf8, 0xd4, 0x99, 0x6c, 0x27, 0xe1, 0x3a, 0x77, 0xbc, 0x2d, 0xa6,
    0xe3, 0x98, 0x1e, 0x99, 0xe5, 0xfb, 0xad, 0x5a, 0x25, 0x21, 0x52, 0xbb, 0x1f, 0xac, 0x93, 0xfe,
    0xb0, 0x5f, 0x1f, 0x4c, 0x57, 0xf3, 0xe5, 0xc3, 0x1a, 0xc6, 0xfd, 0x92, 0x82, 0x2b, 0x38, 0x66,
    0xc3, 0x56, 0xff, 0xa9, 0x52, 0xad, 0x03, 0x77, 0xce, 0x55, 0x33, 0xee, 0x01, 0xc6, 0xec, 0xb2,
    0x25, 0x0b, 0xfe, 0x7c, 0xfe, 0xe4, 0x40, 0x19, 0xaa, 0x3d, 0xab, 0x2d, 0x68, 0xe3, 0x93, 0x2c,
    0x39, 0x92, 0xd5, 0x8b, 0x3f, 0xd8, 0x03, 0x0e, 0x2e, 0x36, 0xfc, 0x2f, 0xfc, 0xe8, 0xe1, 0x22,
    0xf3, 0xe0, 0x9e, 0xf1, 0xc4, 0xde, 0x0a, 0x6e, 0x1c, 0xb5, 0x9b, 0x84, 0x98, 0x2e, 0xb0, 0xd2,
    0xc1, 0x85, 0x5d, 0x00, 0x5e, 0x60, 0x0e, 0x8c, 0x96, 0x0a, 0xbb, 0x93, 0xf2, 0x9d, 0xb5, 0xe5,
    0x7d, 0x53, 0xd7, 0x41, 0x32, 0xe1, 0xaf, 0x4e, 0x97, 0x4b, 0xd2, 0x2f, 0x79, 0x83, 0x01, 0x3a,
    0x08, 0x5f, 0x3b, 0x66, 0xbf, 0x49, 0xf2, 0x56, 0x54, 0xae, 0xe9, 0x46, 0x4b, 0x9e, 0x2c, 0xc8,
    0xf1, 0x03, 0x09, 0x23, 0xe4, 0xb8, 0x71, 0x7b, 0x03, 0x44, 0xab, 0x7d, 0xc7, 0xac, 0xb7, 0xcf,
    0x0b, 0xf2, 0x36, 0xcb, 0x3c, 0x28, 0x21, 0x90, 0xd6, 0x0a, 0xd6, 0x21, 0xa8, 0x02, 0xe9, 0x99,
    0x05, 0xf2, 0xbd, 0xea, 0xab, 0x2e, 0x65, 0xae, 0x72, 0x10, 0x2b, 0x39, 0xbd, 0xe3, 0x09, 0xc8,
    0xd5, 0x3f, 0x93, 0x11, 0x67, 0xb4, 0xa1, 0x3e, 0xbe, 0x78, 0x5f, 0x66, 0x7a, 0x49, 0x00, 0x80,
    0x3b, 0xbd, 0x6a, 0xe6, 0xeb, 0xcf, 0x95, 0x5e, 0xe0, 0xc0, 0x97, 0x9d, 0xa3, 0xa0, 0x65, 0x79,
    0xdf, 0xf9, 0x8a, 0x47, 0xad, 0x2c, 0x85, 0x6c, 0xa4, 0xe4, 0xd2, 0x1e, 0x2d, 0xd2, 0x9e, 0x69,
    0x8f, 0x08, 0x4f, 0x7b, 0xd8, 0xe4, 0xd9, 0xb8, 0xa5, 0x70, 0x55, 0x48, 0x11, 0xba, 0xc1, 0xf0,
    0xb3, 0x4c, 0x37, 0x61, 0x78, 0xbc, 0xcd, 0x1c, 0xa1, 0x9f, 0x3a, 0xce, 0x72, 0xd9, 0x37, 0x01,
    0xe1, 0x87, 0x7c, 0xb9, 0x6b, 0x55, 0x71, 0x10, 0xc6, 0xc6, 0x59, 0xd7, 0x81, 0x1a, 0xc7, 0x34,
    0x66, 0xff, 0x95, 0xde, 0xbb, 0x62, 0xfa, 0x5c, 0x02, 0x35, 0x2b, 0x74, 0x0e, 0x62, 0x75, 0xef,
    0xe9, 0xf2, 0xa9, 0x55, 0x47, 0x1a, 0x65, 0x0d, 0xe1, 0xbe, 0xe4, 0x62, 0xd9, 0xac, 0x96, 0x3f,
    0xab, 0x2c, 0x1e, 0x66, 0x8e, 0x18, 0xc3, 0x90, 0x4d, 0xee, 0x04, 0x5b, 0x50, 0x7a, 0x4b, 0x3a,
    0x6c, 0xf4, 0x8f, 0xb3, 0x0e, 0xf4, 0xc1, 0xef, 0xb3, 0xa5, 0x51, 0x8c, 0x51, 0xe8, 0xcb, 0xfc,
    0x14, 0xe9, 0x63, 0xa2, 0x02, 0x26, 0x33, 0x4f, 0x14, 0x37, 0xab, 0x64, 0xb1, 0xf6, 0x9e, 0x1d,
    0xea, 0x2d, 0xd1, 0xf8, 0x22, 0x92, 0xe8, 0xd5, 0x37, 0x39, 0x61, 0x89, 0x21, 0x2c, 0x85, 0x35,
    0x16, 0xe8, 0xd8, 0x18, 0x0e, 0x0b, 0x67, 0x22, 0x42, 0x12, 0x87, 0xf4, 0x08, 0x25, 0x11, 0xf2,
    0x53, 0xe2, 0xeb, 0x75, 0x74, 0xd3, 0x4a, 0xac, 0x0c, 0xab, 0x35, 0x2e, 0xd7, 0xba, 0x63, 0xed,
    0xa3, 0x3b, 0x05, 0xb1, 0x46, 0x6d, 0xd4, 0x89, 0x7f, 0x5b, 0x7d, 0x88, 0x80, 0x8e, 0x7a, 0xd3,
    0x71, 0x65, 0x48, 0xe5, 0x38, 0x92, 0x91, 0x45, 0x3d, 0xc6, 0x73, 0x15, 0x81, 0xd6, 0x02, 0x24,
    0x12, 0x08, 0xd5, 0x58, 0x75, 0xa9, 0xe1, 0xf4, 0x04, 0x5e, 0x7c, 0x85, 0xed, 0xf7, 0x58, 0x5e,
    0x5c, 0xa1, 0x43, 0x95, 0x33, 0xd5, 0xda, 0x71, 0x9b, 0x4d, 0x86, 0x1c, 0x23, 0x88, 0x40, 0x35,
    0x90, 0x16, 0x8e, 0x05, 0xbf, 0x6f, 0xfa, 0xc4, 0xce, 0x76, 0x49, 0xbb, 0x6d, 0xa1, 0x19, 0xca,
    0x42, 0x5c, 0x5f, 0x76, 0x31, 0x39, 0xe7, 0xcd, 0x86, 0x6d, 0xe9, 0xa9, 0xf5, 0x2a, 0xdf, 0x86,
    0x40, 0x6d, 0x8b, 0xff, 0xdc, 0x85, 0xc3, 0xaa, 0xfc, 0x0c, 0x65, 0x69, 0xae, 0x7e, 0x33, 0xf0,
    0xdb, 0x92, 0x66, 0x0c, 0xcb, 0x4d, 0xd9, 0x51, 0xba, 0xc3, 0xfb, 0xb0, 0xed, 0xda, 0x36, 0x2d,
    0x47, 0xc1, 0x2c, 0x23, 0x47, 0xf0, 0xce, 0x43, 0xfc, 0x33, 0xac, 0xaa, 0xb2, 0xe0, 0x9b, 0x8d,
    0x72, 0x01, 0x99, 0x3e, 0x4f, 0x73, 0x8f, 0x09, 0x36, 0x8a, 0xb9, 0x23, 0x64, 0xef, 0x50, 0xab,
    0xb1, 0x7c, 0xcf, 0xf8, 0x6c, 0x9d, 0x3b, 0x69, 0xd0, 0xe7, 0x13, 0x82, 0xc7, 0xae, 0x0f, 0x3a,
    0xb0, 0xa9, 0x78, 0xff, 0x1c, 0x07, 0x08, 0x52, 0x92, 0xc2, 0x75, 0xf6, 0xb1, 0xc5, 0xa2, 0x62,
    0x41, 0x71, 0x5a, 0xae, 0x0e, 0x95, 0x17, 0xde, 0x7d, 0x2a, 0x61, 0x44, 0xd9, 0x70, 0x7e, 0x89,
    0x19, 0xf6, 0x88, 0x35, 0xfe, 0x90, 0x87, 0x90, 0x52, 0xfc, 0x86, 0x04, 0xc1, 0x28, 0x66, 0x03,
    0x99, 0xc1, 0xb1, 0xa7, 0x56, 0xc8, 0x86, 0xd3, 0xf2, 0xe7, 0x18, 0xcb, 0x57, 0x96, 0x54, 0x71,
    0x8d, 0xdc, 0xa6, 0x8b, 0x6d, 0x2e, 0x1b, 0xbf, 0x2a, 0xa1, 0xc3, 0xec, 0xca, 0x2a, 0xef, 0x63,
    0xeb, 0xa0, 0x0b, 0x41, 0x68, 0x91, 0x15, 0x5a, 0x78, 0x2d, 0x26, 0xcf, 0xc3, 0x7a, 0x40, 0x50,
    0x57, 0xe7, 0xdb, 0xc4, 0x15, 0xf6, 0x83, 0x3f, 0x98, 0x47, 0x2b, 0x62, 0x71, 0x1a, 0xc5, 0x5c,
    0xba, 0xd0, 0x9d, 0x22, 0x61, 0xb2, 0x7d, 0xd9, 0xdf, 0xa3, 0xa9, 0xa3, 0x1d, 0xe9, 0xf3, 0x74,
    0xd0, 0xcf, 0x38, 0xe5, 0xc5, 0xbc, 0x25, 0x5d, 0x03, 0x50, 0xbf, 0x74, 0x6b, 0x85, 0xd0, 0x25,
    0x55, 0x6d, 0x48, 0xb7, 0x20, 0xc5, 0x90, 0xff, 0x68, 0x39, 0xa2, 0x85, 0x23, 0x96, 0xfa, 0xf3,
    0x65, 0x32, 0xd9, 0x2a, 0xee, 0xfe, 0x88, 0xf1, 0x4e, 0x47, 0x65, 0xb9, 0xcc, 0x35, 0xdf, 0x22,
    0xa3, 0x27, 0xd9, 0xc3, 0xec, 0x69, 0xc2, 0x54, 0xa3, 0x65, 0xd9, 0xc6, 0xfb, 0xd3, 0xb9, 0x60,
    0x06, 0x92, 0x8a, 0xf4, 0x90, 0x12, 0xe6, 0xdf, 0x5a, 0x4b, 0x98, 0x26, 0x81, 0x77, 0x48, 0x24,
    0x9e, 0x21, 0xe7, 0x8a, 0x8b, 0xa9, 0xde, 0x2e, 0x0e, 0xb8, 0xf4, 0x09, 0x8b, 0xad, 0x69, 0x91,
    0x40, 0xf4, 0x86, 0xd0, 0x06, 0x6c, 0xaf, 0x60, 0xb7, 0x48, 0x87, 0x38, 0xbf, 0xcf, 0x5c, 0x5e,
    0xf1, 0x43, 0xe8, 0x7c, 0xed, 0xc7, 0xaa, 0xfb, 0x7f, 0x9e, 0x05, 0x0a, 0x4b, 0x6e, 0x9c, 0x8b,
    0x62, 0x22, 0x5c, 0x69, 0x8e, 0x0b, 0xc9, 0x45, 0x53, 0x50, 0x7e, 0x13, 0x20, 0xda, 0x71, 0x11,
    0x1e, 0x59, 0x8d, 0x0b, 0x20, 0x37, 0x06, 0x9f, 0xd5, 0x0b, 0xaa, 0x20, 0x7a, 0x46, 0xac, 0xdc,
    0x68, 0x08, 0x45, 0xf6, 0x13, 0x0f, 0x3b, 0x67, 0x5f, 0xb9, 0x7a, 0x7f, 0x94, 0xeb, 0x90, 0xb2,
    0x44, 0x1d, 0xbd, 0x65, 0x54, 0xc3, 0x04, 0x29, 0xcf, 0xae, 0x4a, 0x49, 0xf4, 0xf6, 0x25, 0x5c,
    0xfe, 0x6b, 0x52, 0x11, 0x7a, 0x8e, 0x78, 0xd9, 0x47, 0xf2, 0x59, 0xdb, 0xdd, 0xe9, 0x8d, 0x22,
    0x07, 0x4a, 0x87, 0x5b, 0x0e, 0x8b, 0x85, 0xdd, 0x3a, 0xcf, 0x26, 0x2e, 0xc5, 0x4b, 0x8b, 0xc3,
    0xb6, 0xdd, 0xd4, 0x30, 0x6b, 0x4d, 0x0a, 0xb3, 0x3f, 0x63, 0x8e, 0x1d, 0x4c, 0x1c, 0x3f, 0x53,
    0x66, 0xc6, 0xaf, 0x74, 0x51, 0x34, 0x51, 0x8b, 0x03, 0x77, 0xba, 0xc8, 0xc3, 0x45, 0x8b, 0x79,
    0x22, 0x5f, 0xaa, 0x8e, 0xac, 0xb4, 0x41, 0xec, 0x17, 0xcf, 0x09, 0x63, 0xeb, 0x48, 0xb7, 0x52,
    0x0e, 0x66, 0xc6, 0x5f, 0x9a, 0x18, 0xeb, 0x9d, 0x8f, 0xa5, 0x65, 0x52, 0xea, 0xf0, 0xcc, 0x0c,
    0x4f, 0x76, 0x9a, 0xfc, 0x2a, 0xdb, 0xe8, 0x41, 0xab, 0xf1, 0xa4, 0x96, 0x39, 0x5b, 0xe8, 0x47,
    0xc1, 0xaf, 0xa6, 0x5b, 0xc7, 0x91, 0xf8, 0x56, 0x36, 0x5d, 0xa9, 0x20, 0x4d, 0x75, 0x2d, 0x9d,
    0xeb, 0xc7, 0x99, 0x15, 0xa3, 0x81, 0x56, 0x4e, 0x72, 0xfa, 0xe4, 0xab, 0x56, 0xcd, 0xf2, 0x17,
    0x7c, 0x98, 0x73, 0x43, 0x2a, 0x6b, 0x99, 0x60, 0xc9, 0x42, 0x81, 0x16, 0xb7, 0xae, 0xb3, 0xa2,
    0x75, 0x4c, 0xb7, 0x18, 0xcd, 0x0d, 0x66, 0x3f, 0x08, 0x4b, 0xea, 0x5e, 0x18, 0xdc, 0x75, 0x94,
    0x75, 0xe8, 0xd7, 0x9f, 0x54, 0x70, 0xff, 0x1d, 0xb3, 0x80, 0x33, 0x6a, 0x2e, 0xe7, 0x0d, 0xa4,
    0x33, 0xc4, 0xbc, 0x01, 0xd2, 0x23, 0x40, 0xda, 0x6e, 0x2b, 0x38, 0x86, 0x07, 0xad, 0x1a, 0x7c,
    0x96, 0xf1, 0x1b, 0xea, 0x61, 0x1b, 0x07, 0x14, 0x9b, 0x3a, 0x7f, 0xca, 0x21, 0x8c, 0x6e, 0x55,
    0x50, 0x2a, 0x56, 0x22, 0x4d, 0x96, 0xfc, 0xbb, 0xc1, 0x34, 0x41, 0xc9, 0xe2, 0x5b, 0x45, 0x78,
    0x4c, 0x61, 0x62, 0xae, 0x7c, 0x69, 0xc2, 0x17, 0xa3, 0x41, 0xe1, 0xc5, 0xcd, 0x4f, 0x1a, 0x1e,
    0x7a, 0x70, 0x40, 0xc7, 0x06, 0x3d, 0x83, 0xc8, 0x71, 0xc4, 0x91, 0x53, 0x20, 0xd6, 0xcb, 0x6c,
    0x37, 0x2d, 0x1a, 0xb3, 0x96, 0xdd, 0xcb, 0x3a, 0x1e, 0xac, 0xff, 0xec, 0xfc, 0x19, 0x0a, 0x76,
    0x89, 0x4a, 0x3d, 0x8f, 0x87, 0xc0, 0x57, 0xf9, 0x85, 0xe8, 0x4c, 0xa5, 0xbf, 0x18, 0x11, 0xf6,
    0x45, 0x2c, 0xaa, 0xdc, 0x09, 0x75, 0x16, 0x27, 0x21, 0x15, 0x13, 0x1d, 0x2e, 0x1d, 0x93, 0xb7,
    0x68, 0xd1, 0x46, 0xef, 0x91, 0x9e, 0xe8, 0x16, 0x86, 0x35, 0xbb, 0x45, 0x4d, 0xcd, 0x3c, 0x92,
    0xf9, 0xe6, 0x6e, 0x02, 0x5b, 0x84, 0x29, 0x7c, 0x99, 0x3d, 0x9a, 0xc7, 0x5a, 0x2d, 0x7e, 0xc2,
    0xfe, 0xc5, 0xb2, 0x90, 0x63, 0x9a, 0xa6, 0xe9, 0xcf, 0x62, 0x2f, 0x1c, 0x2f, 0x6b, 0xaf, 0x28,
    0x51, 0x1d, 0x2a, 0xac, 0xa2, 0x53, 0x28, 0x3b, 0x90, 0xc2, 0x03, 0xeb, 0xf0, 0x81, 0xad, 0xee,
    0x46, 0x5f, 0x7e, 0xa9, 0xfa, 0x25, 0x93, 0xc9, 0x87, 0xc2, 0xe6, 0xb6, 0x2d, 0x95, 0xde, 0x7e,
    0xb2, 0x08, 0x2a, 0x54, 0x5b, 0x52, 0x90, 0xec, 0x15, 0x93, 0xd7, 0x05, 0x14, 0x84, 0xf3, 0x5b,
    0xe4, 0x72, 0x04, 0xde, 0x97, 0x97, 0xa7, 0x1e, 0x59, 0x8d, 0xd4, 0x86, 0x22, 0xb2, 0x04, 0xd5,
    0xba, 0x2e, 0x29, 0x15, 0x81, 0xb9, 0x01, 0x96, 0x4c, 0xd8, 0x9b, 0x61, 0x5d, 0x8e, 0xbc, 0x41,
    0x00, 0xc0, 0x1f, 0x97, 0x58, 0xc6, 0xb5, 0xb1, 0x54, 0x89, 0x38, 0x76, 0x3b, 0x3c, 0x4b, 0xf5,
    0x6b, 0x75, 0x0b, 0xec, 0x2e, 0x0c, 0x82, 0x7b, 0xe5, 0x1d, 0xdc, 0x42, 0xab, 0x98, 0x83, 0xac,
    0x58, 0xa2, 0x43, 0xb0, 0x68, 0xf9, 0x62, 0xbc, 0x82, 0x9a, 0x33, 0xbe, 0xd6, 0x7e, 0xb3, 0x41,
    0xf3, 0xbe, 0x2d, 0x22, 0xcb, 0xaf, 0x9d, 0xb0, 0xcc, 0x79, 0xf2, 0x78, 0x11, 0x75, 0x24, 0x69,
    0x17, 0x67, 0x1a, 0x7f, 0x60, 0x7c, 0x3c, 0xe3, 0x16, 0x6f, 0xa1, 0xec, 0xed, 0x54, 0x2e, 0xe1,
    0x13, 0x5b, 0x03, 0xde, 0x0b, 0xa0, 0x8e, 0xd7, 0x19, 0x80, 0x4f, 0x2a, 0xf5, 0x73, 0x93, 0x0c,
    0xdb, 0xad, 0x8b, 0x3b, 0x29, 0xc7, 0x1e, 0x3f, 0x36, 0xbf, 0x2c, 0x24, 0x14, 0x5a, 0x05, 0x27,
    0xb5, 0x08, 0x05, 0xc0, 0xa8, 0x93, 0x98, 0xc1, 0x13, 0xe7, 0xeb, 0x08, 0x5b, 0x7e, 0x14, 0x36,
    0x2c, 0x9f, 0x71, 0x55, 0x67, 0x90, 0x95, 0x9d, 0x4f, 0xc1, 0xc1, 0x63, 0x1b, 0xc6, 0x8a, 0xd0,
    0xce, 0x8f, 0x91, 0x76, 0x22, 0x29, 0x37, 0x35, 0x10, 0x22, 0x3d, 0x6b, 0xa1, 0x51, 0xa1, 0xcd,
    0xf1, 0x13, 0x22, 0x58, 0xa3, 0xb7, 0xf5, 0xf2, 0x78, 0xb7, 0x56, 0x93, 0x7d, 0xe0, 0x64, 0x4c,
    0x70, 0xf5, 0xc2, 0x92, 0x1e, 0xfa, 0xc8, 0x2e, 0x1c, 0x05, 0x9a, 0xbd, 0x57, 0x3b, 0x8a, 0x48,
    0x4e, 0xad, 0xa0, 0xf1, 0x64, 0x95, 0xe4, 0xdd, 0x4c, 0x3a, 0x70, 0xca, 0x1a, 0xd4, 0x16, 0x8a,
    0xc9, 0xd8, 0x1d, 0xe7, 0xd2, 0xe5, 0x16, 0xef, 0xea, 0xb0, 0xac, 0x41, 0xeb, 0x37, 0x89, 0x3a,
    0xe4, 0x29, 0x2b, 0x48, 0xbf, 0x0f, 0x25, 0x0b, 0x49, 0x96, 0xd5, 0x64, 0x6a, 0xeb, 0xee, 0x34,
    0xc4, 0x0b, 0x1b, 0x96, 0xf0, 0x31, 0x85, 0xdb, 0xe1, 0x32, 0x1c, 0xcd, 0x69, 0xa6, 0x07, 0x4d,
    0xcf, 0x32, 0x95, 0x8e, 0x42, 0xbb, 0x9a, 0x8b, 0x51, 0x6f, 0xef, 0xbb, 0x5b, 0xde, 0xef, 0x1f,
    0xe9, 0x0b, 0xb5, 0xda, 0x3c, 0x3b, 0xb5, 0x1e, 0x6d, 0xd1, 0xeb, 0xd6, 0x77, 0xf2, 0x23, 0x47,
    0x24, 0xb8, 0xd5, 0x66, 0x73, 0x6f, 0xf2, 0xc4, 0xdf, 0xe1, 0x80, 0x3a, 0xbf, 0x6f, 0x59, 0xa9,
    0x7a, 0x0e, 0x83, 0xb7, 0x49, 0x38, 0xd5, 0xb6, 0x09, 0xc0, 0x8c, 0x81, 0xb2, 0xaf, 0xc8, 0xd6,
    0x68, 0x9d, 0x3d, 0xdb, 0x0d, 0x2f, 0xa0, 0xec, 0x10, 0x20, 0x26, 0xd0, 0x8f, 0x7f, 0x79, 0x0a,
    0x8d, 0xfc, 0xc1, 0xd7, 0x34, 0x96, 0x8d, 0x3d, 0x56, 0x1a, 0xbe, 0x08, 0xc9, 0x86, 0xde, 0x31,
    0x24, 0x1b, 0x0d, 0x31, 0x4a, 0xad, 0x1d, 0x5b, 0xcd, 0x43, 0x2b, 0x5c, 0xc2, 0xa4, 0x66, 0x4f,
    0xa0, 0x27, 0x26, 0xd4, 0xbd, 0xb4, 0x11, 0x13, 0xce, 0xd0, 0x1b, 0x97, 0x56, 0xfa, 0xc9, 0x7a,
    0x15, 0xd6, 0xab, 0x60, 0x83, 0xc8, 0xbb, 0x50, 0x0b, 0xe6, 0xac, 0xcd, 0x8a, 0x13, 0x1d, 0x2a,
    0x3a, 0x43, 0xfe, 0xf8, 0xf7, 0x0f, 0x0b, 0xc5, 0xdf, 0x27, 0x5d, 0x36, 0x21, 0x26, 0xb0, 0x36,
    0xfc, 0x5c, 0x96, 0x7f, 0x24, 0x51, 0xcf, 0x30, 0x37, 0x7b, 0xfd, 0xc1, 0x8e, 0x1a, 0xeb, 0xc9,
    0x5e, 0xe9, 0xc1, 0x55, 0xf9, 0xcc, 0x1b, 0xd8, 0xf3, 0x78, 0x0e, 0x14, 0x9e, 0xbf, 0x4b, 0x9a,
    0x1b, 0xe1, 0x19, 0x3f, 0x33, 0xe8, 0x6f, 0x6a, 0x63, 0x6d, 0x2c, 0xf2, 0x87, 0x17, 0xbb, 0xe5,
    0x01, 0x7c, 0x3b, 0xfa, 0x48, 0x56, 0xd2, 0x3c, 0xce, 0xe1, 0x50, 0x6c, 0xa0, 0x9b, 0x06, 0xbb,
    0x7d, 0x1f, 0xfa, 0xb0, 0x07, 0x6a, 0x1a, 0x6a, 0xd7, 0x46, 0x5c, 0x5e, 0x5e, 0x17, 0x44, 0x5f,
    0x93, 0x7f, 0x59, 0xdc, 0xd5, 0x2b, 0x18, 0xa3, 0x0c, 0x68, 0x0f, 0xac, 0x04, 0x15, 0x67, 0x81,
    0x34, 0x62, 0x31, 0x3b, 0xcc, 0x4b, 0xa5, 0xa3, 0x92, 0x02, 0x01, 0xf0, 0x19, 0x45, 0x4f, 0xad,
    0xc4, 0xa8, 0x89, 0x99, 0xd3, 0xa1, 0x3c, 0xe0, 0x09, 0x4b, 0x8c, 0x0d, 0x60, 0xf4, 0x8e, 0x94,
    0x56, 0xbf, 0xcf, 0x22, 0x0b, 0x75, 0xc5, 0x9d, 0x77, 0xc6, 0x8d, 0x90, 0x0c, 0xdc, 0x3d, 0xd0,
    0x84, 0xc6, 0x6a, 0x57, 0x67, 0xa6, 0x37, 0x71, 0xf2, 0xc4, 0x7e, 0x52, 0xb8, 0x0d, 0xe7, 0x0e,
    0xcc, 0xb6, 0x30, 0xd7, 0x2b, 0xf5, 0x74, 0xa2, 0xbb, 0x01, 0x33, 0xc7, 0xdd, 0x70, 0x98, 0x61,
    0x37, 0x02, 0xb9, 0x9e, 0xa8, 0xf0, 0x0f, 0x9a, 0xb4, 0x8e, 0xed, 0x6c, 0x9b, 0xd4, 0x7a, 0x67,
    0x8a, 0xaa, 0x3f, 0xb6, 0x9f, 0xb3, 0x58, 0x5b, 0xb5, 0x8b, 0x22, 0x92, 0xfc, 0xba, 0xf4, 0x33,
    0xbc, 0xad, 0xd1, 0x65, 0x9d, 0xe1, 0xff, 0x52, 0x6f, 0xec, 0xbe, 0x0a, 0xc0, 0x39, 0x71, 0x4b,
    0xe3, 0xb0, 0x01, 0x83, 0x64, 0x59, 0xde, 0x19, 0xe5, 0x00, 0xab, 0xe1, 0xbb, 0x9f, 0x14, 0x77,
    0x4c, 0xe5, 0xdc, 0xea, 0xc6, 0xdc, 0x3c, 0x35, 0xc8, 0xfa, 0x3f, 0x89, 0x33, 0xb1, 0xd4, 0x17,
    0x61, 0xd5, 0x9a, 0xc5, 0x2e, 0x78, 0xde, 0x13, 0x78, 0x8a, 0xf4, 0x33, 0x29, 0x08, 0xab, 0x76,
    0xee, 0x87, 0x60, 0xb4, 0x63, 0x9c, 0xea, 0x2c, 0x96, 0x29, 0xb5, 0xca, 0xda, 0x89, 0xe1, 0x3c,
    0x5e, 0x7b, 0x01, 0x8c, 0xf3, 0xe0, 0xa0, 0x6b, 0x6a, 0x94, 0x9f, 0x93, 0x9d, 0x4a, 0x09, 0x8b,
    0xd1, 0x69, 0x3f, 0x35, 0x05, 0x29, 0x61, 0x9c, 0x53, 0x16, 0x66, 0x2d, 0x9f, 0x47, 0x69, 0xfd,
    0xc2, 0x6b, 0x89, 0xb5, 0x4b, 0x29, 0x20, 0xb5, 0xbe, 0xbf, 0x48, 0x5b, 0x09, 0x52, 0xe6, 0xdb,
    0xbb, 0x25, 0x10, 0xc1, 0x4f, 0x71, 0x5d, 0xa2, 0x87, 0xc3, 0xcf, 0x26, 0x0a, 0x39, 0x23, 0xcc,
    0xa4, 0xac, 0x81, 0xef, 0xd6, 0xa1, 0xa4, 0x94, 0x61, 0xec, 0xef, 0x6a, 0x3e, 0xd5, 0x45, 0xfa,
    0xfa, 0x55, 0xbb, 0x49, 0xc6, 0x18, 0xeb, 0x4d, 0xdb, 0xbb, 0x73, 0xe5, 0xf4, 0x96, 0xb1, 0x98,
    0x43, 0x32, 0x87, 0x19, 0xd3, 0x2b, 0xad, 0x34, 0x17, 0x9c, 0x9f, 0x56, 0x71, 0xe4, 0x50, 0x6b,
    0x3a, 0x0b, 0xb5, 0x00, 0x23, 0xa0, 0x4e, 0xfe, 0x5b, 0xc1, 0xe3, 0x4f, 0x58, 0x94, 0xe7, 0x9b,
    0xc6, 0x6e, 0xb4, 0x99, 0x99, 0x61, 0xce, 0xb1, 0xfd, 0x6d, 0x07, 0x6e, 0x51, 0x57, 0xd9, 0x8b,
    0x62, 0x8e, 0x8c, 0x85, 0x2f, 0xda, 0x83, 0x8a, 0x9b, 0x66, 0xda, 0xf3, 0xfa, 0xc1, 0x8e, 0xc0,
    0x30, 0x42, 0x59, 0xc9, 0xa3, 0x27, 0x7a, 0xa0, 0x94, 0x81, 0x0e, 0xe6, 0xd8, 0xe8, 0x71, 0x3a,
    0x76, 0xfd, 0xbf, 0xa5, 0xd7, 0x42, 0x30, 0x73, 0xa8, 0x0a, 0x66, 0xa2, 0xcb, 0xf5, 0x62, 0xfb,
    0x37, 0xbc, 0xc5, 0xdb, 0xe3, 0x3f, 0x7b, 0x78, 0xc1, 0x8a, 0x5e, 0x99, 0x72, 0xcf, 0xd4, 0xe8,
    0xcd, 0x93, 0x8e, 0xa4, 0xd6, 0xbe, 0x17, 0x7e, 0xc8, 0x7e, 0x21, 0x93, 0x73, 0x83, 0x8f, 0xaa,
    0x3f, 0x54, 0x85, 0x23, 0x93, 0x01, 0x9b, 0x54, 0x8b, 0xf9, 0xee, 0xfd, 0xc8, 0xc2, 0xe5, 0x95,
    0x55, 0x73, 0x3a, 0x2b, 0x31, 0x51, 0xaa, 0xf9, 0xcf, 0xcb, 0x8d, 0x42, 0x4e, 0x1c, 0xed, 0x8e,
    0x70, 0x72, 0xb1, 0x03, 0x73, 0x4c, 0x58, 0xfe, 0x45, 0x46, 0xfb, 0x0d, 0x08, 0xe1, 0xa3, 0x5d,
    0x54, 0xdd, 0x89, 0x86, 0x2e, 0x33, 0x7f, 0xfe, 0xfe, 0x0c, 0x40, 0x4c, 0x28, 0x2d, 0xda, 0x98,
    0xa0, 0x8b, 0x9c, 0x13, 0xd7, 0xf4, 0x12, 0x1c, 0x3a, 0x0d, 0x2a, 0x42, 0xee, 0xcd, 0x9f, 0x43,
    0xaa, 0x28, 0xc9, 0xd8, 0x5b, 0x48, 0xd6, 0x59, 0x55, 0x17, 0xa6, 0x7d, 0x44, 0x80, 0x16, 0xe4,
    0x0c, 0xb2, 0xf8, 0xe3, 0xa6, 0x0a, 0x00, 0xe0, 0x17, 0x2a, 0x22, 0x06, 0xf7, 0xc1, 0x49, 0xa1,
    0xea, 0x12, 0x79, 0x45, 0x5a, 0x50, 0x9f, 0xaf, 0x67, 0x45, 0x2d, 0xab, 0xc5, 0x43, 0x90, 0xd1,
    0xf5, 0x88, 0xb5, 0x9b, 0x92, 0xb5, 0x7b, 0xa9, 0xdf, 0x9d, 0xaf, 0xd6, 0x5e, 0xf8, 0x77, 0x48,
    0x0a, 0xf0, 0x8e, 0x65, 0x40, 0x2d, 0x14, 0xa7, 0x72, 0x41, 0x53, 0x37, 0x84, 0xe3, 0x09, 0x79,
    0x6b, 0xbe, 0x14, 0xfd, 0x73, 0x8f, 0xa6, 0x52, 0x2c, 0x56, 0x28, 0x8b, 0x4e, 0x9f, 0xd3, 0x59,
    0x8f, 0x61, 0xbe, 0xd0, 0x8e, 0xd2, 0x77, 0x00, 0x14, 0xca, 0x38, 0x98, 0xad, 0x41, 0x12, 0x18,
    0xff, 0x26, 0x15, 0x72, 0xb6, 0xbc, 0xc4, 0xe2, 0x12, 0xec, 0x6d, 0x60, 0x8b, 0x41, 0xb9, 0x1a,
    0xa2, 0x77, 0xea, 0x31, 0x4a, 0x62, 0x31, 0x5e, 0x2c, 0x69, 0xf6, 0xda, 0xaa, 0x08, 0xf2, 0xa9,
    0x2f, 0x08, 0x1b, 0xe5, 0xc4, 0xdf, 0xc7, 0xd6, 0xcb, 0x35, 0x36, 0x56, 0x76, 0xf0, 0x71, 0x18,
    0x67, 0x5b, 0x49, 0xb1, 0xbd, 0x7b, 0x0f, 0xea, 0xe4, 0x06, 0xc4, 0x8f, 0x0e, 0xb6, 0x38, 0x3d,
    0xbe, 0x54, 0x22, 0x82, 0x33, 0xea, 0x58, 0xff, 0x1f, 0x8f, 0x55, 0x95, 0x7f, 0xc6, 0xad, 0xe6,
    0x22, 0xf7, 0x98, 0xdf, 0x72, 0xa7, 0xc9, 0x56, 0xad, 0x8d, 0xe5, 0xbc, 0x44, 0x1e, 0xf9, 0x02,
    0x72, 0x1c, 0x85, 0xa5, 0x06, 0xdd, 0xa4, 0x25, 0x6c, 0xfa, 0xba, 0xeb, 0xc0, 0x67, 0xd2, 0xe2,
    0x5e, 0x6a, 0xc2, 0xd0, 0x11, 0x8b, 0x27, 0xbf, 0x19, 0x0c, 0x7b, 0x5d, 0x2a, 0x74, 0x5f, 0x9c,
    0x90, 0xe4, 0x42, 0x96, 0xc2, 0xe6, 0xbb, 0x2e, 0xe0, 0x75, 0x1a, 0xa1, 0xdd, 0xec, 0x83, 0x3b,
    0x56, 0x45, 0x0c, 0x67, 0xd1, 0x33, 0x26, 0xea, 0x3f, 0xa1, 0x47, 0x6a, 0x16, 0xa6, 0x06, 0xa6,
    0x8b, 0x48, 0x3d, 0x4d, 0x2f, 0xf8, 0x7b, 0x0f, 0x6e, 0x95, 0xb0, 0x4b, 0x81, 0x34, 0x86, 0xd7,
    0x79, 0x92, 0x3f, 0x4a, 0xc5, 0x65, 0x34, 0x05, 0x07, 0x7b, 0x6f, 0x1d, 0x22, 0x75, 0xc3, 0xad,
    0xbe, 0x00, 0xfa, 0xed, 0xf9, 0x75, 0xfc, 0x67, 0x0b, 0xad, 0xb2, 0x8c, 0xe1, 0x38, 0x64, 0x5a,
    0xcb, 0xa3, 0xa5, 0x90, 0x08, 0xd9, 0x95, 0x0f, 0x55, 0x04, 0x2c, 0x77, 0x7a, 0xf0, 0x24, 0x38,
    0xf0, 0x1e, 0x25, 0xe9, 0x93, 0x21, 0x50, 0x9e, 0xce, 0x02, 0x2b, 0xaf, 0x3b, 0x8f, 0x0a, 0x06,
    0x32, 0xaf, 0x96, 0x3a, 0x88, 0x2c, 0x4a, 0xdd, 0x30, 0x76, 0x54, 0xaa, 0x66, 0x78, 0xe2, 0x57,
    0x96, 0x07, 0x40, 0x2a, 0x29, 0x91, 0xc8, 0xf7, 0x93, 0xf3, 0xa7, 0xce, 0x82, 0xb1, 0xd4, 0xb4,
    0x60, 0x6b, 0xef, 0xe8, 0x97, 0x39, 0xc6, 0xc7, 0xaf, 0x1a, 0x72, 0x16, 0x93, 0x54, 0x6d, 0x29,
    0x5c, 0xad, 0x53, 0x85, 0x3e, 0x1c, 0x7c, 0xd2, 0x0f, 0x23, 0xa0, 0x92, 0xd4, 0x75, 0x46, 0x34,
    0xe0, 0x35, 0x1d, 0x77, 0x6e, 0xe3, 0x3e, 0x1e, 0xfd, 0xb0, 0x34, 0x90, 0x05, 0xa1, 0xba, 0x61,
    0x4e, 0x0d, 0xe6, 0x8d, 0x29, 0x62, 0x5f, 0x39, 0x86, 0xff, 0xcb, 0x5a, 0x74, 0x11, 0x8f, 0x54,
    0x47, 0xac, 0xcb, 0xb5, 0x8f, 0x0a, 0xd3, 0x8c, 0xba, 0x07, 0x1d, 0xbf, 0xa8, 0xd7, 0x20, 0xf7,
    0xe4, 0x06, 0x84, 0x0e, 0x69, 0xe3, 0x47, 0xef, 0xe2, 0x12, 0x49, 0x57, 0x23, 0xd8, 0xab, 0x6a,
    0x84, 0x77, 0x20, 0x13, 0x81, 0xf3, 0xa0, 0x3b, 0xfb, 0xbd, 0xfb, 0xa3, 0x94, 0x1b, 0x9a, 0x78,
    0x22, 0x1e, 0x86, 0x8b, 0x01, 0xcd, 0x7a, 0xe4, 0xdf, 0xc3, 0x3b, 0x03, 0x9c, 0xe6, 0x6d, 0x20,
    0x5d, 0x8d, 0x34, 0xde, 0x81, 0xd4, 0x1a, 0x7c, 0x91, 0x15, 0x1f, 0x25, 0x30, 0xba, 0x9d, 0x52,
    0xd8, 0x24, 0xdd, 0xda, 0xf1, 0x57, 0xbe, 0xd1, 0x1b, 0xf9, 0xd4, 0xb7, 0xdf, 0x41, 0xd7, 0x3d,
    0xcf, 0x0b, 0x1b, 0x50, 0xdf, 0x35, 0xcc, 0x70, 0x4a, 0xeb, 0x95, 0x7b, 0xa5, 0x33, 0xcd, 0x7e,
    0x57, 0xab, 0x58, 0x48, 0x02, 0x16, 0x19, 0x1d, 0x0f, 0xed, 0xd4, 0xee, 0x2f, 0xac, 0x2b, 0xfe,
    0xb7, 0x47, 0x4e, 0x97, 0x7c, 0x1a, 0x07, 0xc7, 0x05, 0x9d, 0x42, 0xab, 0xd0, 0x0f, 0x29, 0x27,
    0xba, 0x81, 0x6f, 0xbd, 0x97, 0x89, 0xda, 0xa6, 0x76, 0xaf, 0x94, 0xa5, 0x5b, 0xc0, 0xa3, 0x12,
    0x07, 0xf1, 0xa9, 0x83, 0x0b, 0xb1, 0x4a, 0x11, 0x4e, 0x8c, 0xbc, 0x1e, 0x9c, 0xe5, 0x45, 0x56,
    0x66, 0xb4, 0x13, 0xfd, 0x3d, 0xee, 0xa3, 0xb4, 0x9d, 0x37, 0x59, 0xf8, 0xf7, 0xfd, 0x0a, 0xfe,
    0xee, 0xb4, 0x82, 0xfa, 0x65, 0xcc, 0x0b, 0xb3, 0x59, 0xc7, 0xd1, 0xf5, 0xac, 0x16, 0x4b, 0x12,
    0xca, 0x5f, 0x0f, 0x08, 0x4d, 0xb2, 0xbc, 0xea, 0xe9, 0x15, 0xe2, 0xe1, 0x12, 0xec, 0xdf, 0x01,
    0xa0, 0x61, 0xfb, 0x05, 0x2e, 0x06, 0xb8, 0x87, 0xcd, 0x89, 0x7c, 0x79, 0x9f, 0xc7, 0x8b, 0x6a,
    0x26, 0x9a, 0x72, 0x73, 0x4c, 0x2e, 0x5d, 0x35, 0x43, 0x3f, 0x16, 0x56, 0x2c, 0xf6, 0x57, 0xcc,
    0x57, 0x52, 0xd2, 0x85, 0x58, 0x8a, 0x0c, 0x25, 0x14, 0x88, 0x9e, 0xb3, 0x50, 0x29, 0x1d, 0x76,
    0xc3, 0x8f, 0xea, 0x0f, 0xbd, 0x47, 0x44, 0x01, 0x87, 0x5b, 0x57, 0xb3, 0x51, 0xae, 0x7f, 0xa8,
    0x00, 0x51, 0x2e, 0x58, 0xdc, 0x3a, 0x7d, 0xf0, 0xc3, 0x1b, 0xa3, 0x13, 0x44, 0xc1, 0x89, 0x07,
    0x50, 0x73, 0x16, 0x0e, 0xbb, 0x5a, 0x0f, 0x42, 0xb5, 0x66, 0xf5, 0x06, 0x14, 0x74, 0xaf, 0x14,
    0xc6, 0xdd, 0x6c, 0xa2, 0x17, 0xe9, 0x92, 0xda, 0x04, 0x35, 0xed, 0x48, 0xf6, 0x77, 0x4f, 0x47,
    0xea, 0x65, 0x55, 0xa5, 0xbf, 0x64, 0xe7, 0x75, 0xca, 0xdc, 0x7b, 0xde, 0x51, 0x2a, 0xf2, 0x17,
};

CLIENT::CLIENT(int id):devid(id)
{
    //    stdout_copy = dup(1);
}

CLIENT::~CLIENT()
{
    delete  logout;
    delete  tcp_head_svr;
    log.close();
}

teestream::teestream(std::ostream & o1, std::ostream & o2)
    : std::ostream(&tbuf)
    , tbuf(o1.rdbuf(), o2.rdbuf())
{
}

void CLIENT::get_randstr(u_char str[], int len)
{
    srand(time(0) + getpid());
    for (int i=0; i<len; i++)
    {
        switch (rand()%3) {
        case 0:
            str[i] = 'a' + rand()% 26;
            break;
        case 1:
            str[i] = 'A' + rand()% 26;
            break;
        case 2:
            str[i] = '0' + rand()% 10;
            break;
        default:
            break;
        }
    }
}

int CLIENT::tcp_send(int s, char *buf, int len)
{
    int sum = 0;
    int n;
    while(sum < len)
    {
        n = send(s, buf + sum, len - sum, 0);
        if (n < 0) continue;
        sum += n ;
    }
    if (TS_CONF.DEBUG[2] == '1')    *logout<< getTime()<<"发送 "<<n<<" 字节"<<endl;
    if (TS_CONF.DEBUG[4] == '1')
    {
        *logout<< getTime() <<"(发送的数据为:)"<<endl;
        tcp_print(buf, len);
    }
    return len;
}

void CLIENT::tcp_print(const char* tcp, int size)
{
    for (int i=0, j=0; i*16<size; i++)
    {
        *logout << setiosflags(ios::right) ;
        *logout << "  " << hex<< setw(4) << setfill('0')<< i;
        *logout << ":";
        for (int k=0; k<8 && j<size; k++,j++)
            *logout <<" " << hex <<setw(2) << setfill('0') <<(u_int)(u_char)*(tcp + j);
        *logout<<" -";
        for (int k=0; k<8 && j<size; k++,j++)
            *logout <<" " << hex <<setw(2) << setfill('0') <<(u_int)(u_char)*(tcp + j);
        *logout << endl;
    }
    *logout <<dec <<endl;
}


u_short CLIENT::readfile(const char *filename, u_char *buff, u_short &len)
{
    ifstream conf(filename);
    if (!conf.is_open())
    {
        if (TS_CONF.DEBUG[1] == '1')    *logout<< getTime()<<"无法打开文件"<<endl;
        return -1;
    }

    conf.read((char *)buff, len);
    len = conf.gcount() ;
    buff[len++] = '\0';
    conf.close();
}


void CLIENT::init()
{
    char    filename[16];
    sprintf(filename, "%sts.%d.log", TsConf::LOG_PATH, devid);
    if (TS_CONF.DEL_LOG)
        log.open(filename, ios_base::out);
    else
        log.open(filename, ios_base::app);
    if (!log.is_open())
    {
        if (TS_CONF.DEBUG[1] == '1')    *logout<< getTime()<<"无法打开配置文件\n";
    }

    if (!TS_CONF.PRINT_DEBUG_INFO)
    {
        close(1);
        open("/dev/null",O_RDWR);
    }

    logout = new teestream(std::cout, log);
    tcp_head_svr = new TCP_HEAD;
    finished = false;
}

void CLIENT::run()
{
    int     _devnum = 0;
    int     _scrnum = 0;
    u_char  asyncnum ;

    fd_set  rset , wset;

    if (!socketInit())
    {
        return ;
    }
    while(1)
    {
        FD_ZERO(&rset);
        FD_ZERO(&wset);
        FD_SET(clientfd, &rset);
        FD_SET(clientfd, &wset);
        switch(select(clientfd + 1, &rset, &wset, NULL, NULL))
        {
        case -1:
            *logout << "select error" << endl;
            break;
        case 0:
            *logout << "对端已经关闭，接收中断" << endl;
            close(clientfd);
            return ;
        default:
            if (FD_ISSET(clientfd, &rset))
            {
                char    buf[BUFSIZE];
                int     buf_recvlen ;
                int     buf_handled = 0;

                buf_recvlen = recv(clientfd, buf, BUFSIZE, 0);
                if (buf_recvlen == 0)
                {
                    if (!finished)  //传输未完成
                    {
                        *logout << getTime() << "[接收数据错误，关闭连接]" << endl;
                        close(clientfd);
                        return ;
                    }
                    else if (TS_CONF.DEBUG[0] == '1')
                    {
                        *logout << getTime() << "[接收完成]" << endl;
                        *logout<< getTime() <<"[结果已写入]"<<endl;
                    }
                    ofstream xlscount;
                    xlscount.open(TsConf::COUNT_PATH, ios_base::app);
                    xlscount << '\t' <<dec << devid << '\t' << 1 << '\t' << _devnum << '\t' << _scrnum <<endl;
                    xlscount.close();
                    close(clientfd);
                    return ;

                }
                else if (buf_recvlen < 0)
                {
                    if (TS_CONF.DEBUG[1] == '1')    *logout << getTime() << "传输出现错误，连接关闭" << endl;
                    close(clientfd);
                    return ;
                }

                if (TS_CONF.DEBUG[3] == '1')    *logout << getTime() << "读取" << buf_recvlen << "字节" <<endl;
                if (TS_CONF.DEBUG[5] == '1')
                {
                    *logout << getTime() << "(读取的数据为)" <<endl;
                    tcp_print(buf, buf_recvlen);
                }
                while (buf_handled < buf_recvlen)
                {
                    memcpy(tcp_head_svr, buf + buf_handled, 8);
                    if (tcp_head_svr->h1 != 0x11)
                    {
                        if (TS_CONF.DEBUG[1] == '1') *logout << "传输出现错误，错误的类型"<<hex<<(u_int)tcp_head_svr->h1 << endl;
                        close(clientfd);
                        return ;
                    }
                    switch(tcp_head_svr->h2)
                    {
                    case 0x01:
                        *logout<< getTime() << "收到客户端状态请求[intf=认证信息]" << endl;
                        authentication(buf + 8, clientfd, asyncnum);
                        buf_handled += ntohs(tcp_head_svr->head_datalen) ;
                        break;
                    case 0x02:
                        *logout<< getTime() << "收到客户端状态请求[intf=系统信息]" << endl;
                        send_sys_info_tosvr(clientfd);
                        break;
                    case 0x03:
                        *logout<< getTime() << "收到客户端状态请求[intf=配置信息]" << endl;
                        send_conf_info_tosvr(clientfd);
                        break;
                    case 0x04:
                        *logout<< getTime() << "收到客户端状态请求[intf=进程信息]" << endl;
                        send_pid_info_tosvr(clientfd);
                        break;
                    case 0x05:
                        *logout<< getTime() << "收到客户端状态请求[intf=以太口"<<ntohs(tcp_head_svr->h3)<<"信息]" << endl;
                        send_eth_info_tosvr(clientfd, ntohs(tcp_head_svr->h3));
                        break;
                    case 0x07:
                        *logout<< getTime() << "收到客户端状态请求[intf=USB信息]" << endl;
                        send_usb_info_tosvr(clientfd, 0x01);
                        break;
                    case 0x08:
                        *logout<< getTime() << "收到客户端状态请求[intf=打印口信息]" << endl;
                        send_prinet_info_tosvr(clientfd, 0x01);
                        break;
                    case 0x09:
                        *logout<< getTime() << "收到客户端状态请求[intf=终端服务信息]" << endl;
                        send_tsevser_info_tosvr(clientfd, asyncnum, _devnum);
                        break;
                    case 0x0a:
                        *logout<< getTime() << "收到客户端状态请求[intf=哑终端" << ntohs(tcp_head_svr->h3) << "口信息]" << endl;
                        send_tty_info_tosvr(clientfd, _scrnum);
                        break;
                    case 0x0b:
                        *logout<< getTime() << "收到客户端状态请求[intf=Ip终端" << ntohs(tcp_head_svr->h3) << "口信息]" << endl;
                        send_tty_info_tosvr(clientfd, _scrnum);
                        break;
                    case 0x0c:
                        *logout<< getTime() << "收到客户端状态请求[intf=U盘文件列表信息]" << endl;
                        send_usb_fileinfo_tosvr(clientfd);
                        break;
                    case 0x0d:
                        *logout<< getTime() << "收到客户端状态请求[intf=打印队列信息]" << endl;
                        send_prinet_list_tosvr(clientfd);
                        break;
                    case 0xff:
                        *logout<< getTime() << "收到客户端状态请求[intf=本次接收完成]" << endl;
                        tcp_head_svr->h1 = 0x91 ;
                        *logout<< getTime() << "发送客户端状态请求[intf=本次接收完成 len =8]"<< endl;
                        mempush((char*)tcp_head_svr, sizeof(TCP_HEAD));
                        finished = true;
                        break;
                    default:
                        break;
                    }
                    buf_handled += 8;
                }
            }
            if (FD_ISSET(clientfd, &wset) && sender.len)
            {
                tcp_send(clientfd, sender.buffer, sender.len);
                sender.len = 0;
            }
            break;
        }
    }
}

void CLIENT::start()
{
    init();
    while(1)
    {
        run();
        if  (TS_CONF.EXIT)
        {
            return ;
        }
        *logout<< getTime() << "在" << dec << TS_CONF.TIME_GAP<< "秒后重新连接..." << endl;
        sleep(TS_CONF.TIME_GAP);
    }
}

int CLIENT::authentication(char *buf, int sock, u_char &async_num)
{
    struct TCP_AUTH_SERVER
    {
        u_short     svr_version     ;
        u_char      svr_version_1   ;
        u_char      svr_version_2   ;
        u_short     svr_time_fail_gap;
        u_short     svr_time_succ_gap;
        u_char      svr_isnull;
        u_char      pad[3];
        u_char      svr_authstr[32];
        u_int       svr_randnum;
        u_int       svr_time;
    } server;

    memcpy(&server, buf, sizeof(TCP_AUTH_SERVER));

    u_short     pos ;
    char    timestr[30];
    time_t t = (time_t)ntohl(server.svr_time);
    time(&t);
    strftime(timestr, 50, "%Y.%m.%d %H:%M:%S",localtime(&t));
    pos = ntohl(server.svr_randnum)% 4093 ;
    TS_CONF.TIME_GAP = ntohs(server.svr_time_fail_gap) ;
    *logout<< getTime() << "收到服务器的时间:" << timestr << endl;
    *logout<< getTime() << "收到连接间隔为=" << dec << TS_CONF.TIME_GAP <<"/采样间隔="<< ntohs(server.svr_time_succ_gap)<<endl;

    for (int i=pos, j = 0; j<32 && i<4096; i++, j++)
    {
        if (server.svr_authstr[j] ^ secret[i] ^ (u_char)TS_CONF.KEY_AUTH[j])
        {
            *logout<< getTime() <<"非法认证" << endl;
            return 0;
        }
    }
    if (strcmp(timestr, "2017-01-01 00:00:00") == -1)
    {
        *logout<< getTime() << "数字证书过期" << endl;
        return 0;
    }
    if (ntohs(server.svr_version) < 2)
    {
        *logout<< getTime() << "发送最低版本要求" << endl;
        version_request(sock);
        return 0;
    }

    //设备向服务器发送认证串及基本配置信息
    struct TCP_AUTH_CLIENT
    {
        TCP_HEAD    head;
        short   base_cpu ;
        short   base_ram ;
        short   base_flash ;
        short   base_inid;
        u_char  base_groupid[16];
        u_char  base_type[16];
        u_char  base_version[16];
        u_char  base_ethnum;
        u_char  base_syncum;
        u_char  base_asyncnum;
        u_char  base_switchnum;
        u_char  base_usbnum;
        u_char  base_prnum;
        u_char  pad[2];
        u_int   base_devid;
        u_char  base_seq;
        u_char  pad1[3];
        u_char  base_authstr[32];
        u_int   base_randnum;
    };

    u_short     len = sizeof(TCP_AUTH_CLIENT) ;
    TCP_AUTH_CLIENT client = { {0x91, 0x01, ntohs(len), htons(0), ntohs(len - 8)}};
    srand(time(0) + getpid());

    get_randstr(client.base_groupid, 16);
    get_randstr(client.base_type, 16);
    get_randstr(client.base_version,16);

    client.base_ethnum = 2;
    client.base_syncum = 1;
    client.base_usbnum = 1;
    client.base_prnum = 1;
    client.base_inid = htons(1);
    client.base_devid = htonl(devid);
    client.base_seq = 1 ;
    client.base_cpu = htons(2394);
    client.base_ram = htons(1870492 / 1024);
    client.base_flash = htons(rand() % 1000000);
    client.base_randnum = (u_int)rand();
    pos               = (client.base_randnum % 4093);
    client.base_randnum = htonl(client.base_randnum);
    memcpy(client.base_authstr, (u_char*)TS_CONF.KEY_AUTH, 32);

    switch (rand()%3) {
    case 0:
        async_num = 0;
        client.base_switchnum = 0;
        break;
    case 1:
        async_num = 8;
        client.base_switchnum = 8;
        break;
    case 2:
        async_num = 16;
        client.base_switchnum = 16;
        break;
    default:
        break;
    }

    client.base_asyncnum = async_num;

    for (int i=pos, j = 8; j<112; (++i)%=4096, j++)
    {
        *((u_char*)&client + j) =  *((u_char*)&client + j) ^ secret[i] ;
    }

    *logout<< getTime() << "发送客户端状态应答[intf=认证信息 len=" <<len <<"]" << endl;
    tcp_send(sock, (char *)&client, len);
    return 1;
}

void CLIENT::version_request(int sock)
{
    struct TCP_VERSION_CLIENT
    {
        TCP_HEAD head;
        u_short version;
        u_char  version1;
        u_char  version2;
    };
    u_short len = sizeof(TCP_VERSION_CLIENT);
    TCP_VERSION_CLIENT client = { {0x91, 0x00, htons(len), htons(0), htons(len - 8)}, htons(2), 0x00, 0x00};
    mempush((char *)&client, len);
}

void CLIENT::send_sys_info_tosvr(int sock)
{
    struct  TCP_SYS_INFO
    {
        TCP_HEAD head;
        u_int   cput_1;
        u_int   cput_2;
        u_int   cput_3;
        u_int   cput_4;
        u_int   freemem;
    };

    int len = sizeof(TCP_SYS_INFO);
    TCP_SYS_INFO client = { {0x91,0x02, htons(len), htons(0), htons(len - 8)}, htonl(2343), htonl(31), htonl(6205), htonl(3319452), htonl(4083176/1024)} ;

    *logout<< getTime() << "发送客户端状态应答[intf=系统信息 len=" <<len <<"]" << endl;
    mempush((char *)&client, len);
}

void CLIENT::send_conf_info_tosvr(int sock)
{
    struct  TCP_CONF_INFO
    {
        TCP_HEAD head;
        u_char  conf[8191 + 1];
    };

    TCP_CONF_INFO client ;  //先不做初始化
    u_short len = 8191 ;
    readfile(TS_CONF.CONFIG_PATH, client.conf, len);

    len += 8;   //加头部长度

    client.head.h1 = 0x91; client.head.h2 = 0x03;
    client.head.headlen = htons(len);
    client.head.h3 = 0;
    client.head.head_datalen = htons(len - 8);

    *logout<< getTime() << "发送客户端状态应答[intf=系统配置信息 len=" <<len <<"]" << endl;
    mempush((char *)&client, len);

}

void CLIENT::send_pid_info_tosvr(int sock)
{
    struct  TCP_PID_INFO
    {
        TCP_HEAD head;
        u_char   pro[8191 + 1];
    };

    TCP_PID_INFO client ;  //先不做初始化
    u_short len = 8191;
    readfile(TS_CONF.PRO_PATH, client.pro, len);

    len += 8;   //加头部长度

    client.head.h1 = 0x91; client.head.h2 = 0x04;
    client.head.headlen = htons(len);
    client.head.h3 = 0;
    client.head.head_datalen = htons(len - 8);

    *logout<< getTime() << "发送客户端状态应答[intf=进程信息 len=" <<len <<"]" << endl;
    tcp_send(sock, (char*)&client, len);
//    mempush((char *)&client, len);

}

void CLIENT::send_eth_info_tosvr(int sock, short ethnum)
{
    struct  TCP_ETH_INFO
    {
        TCP_HEAD head;
        u_char  isexists;
        u_char  isconf;
        u_char  isup;
        u_char  pad;
        u_char  mac[6];
        u_short options;
        u_char  ip[48];
        u_int   data[16];
    };

    int len = sizeof(TCP_ETH_INFO);
    TCP_ETH_INFO client = { {0x91,0x05, htons(len), htons(ethnum), htons(len - 8)}} ;

    client.isexists = 0x01;
    client.isconf = 0x01;
    client.isup = 0x01;
    client.isexists = 0x01;

    u_char  mac[] = {0xa0, 0x88, 0x69, 0x8d, 0xd1, 0x79, 0x00, 0x07};
    u_char  ip[48]     = {0xc0, 0xa8, 0x64, 0x06, 0xff, 0xff, 0xff, 0xff,
                          0xc0, 0xa8, 0x64, 0x01, 0xff, 0xff, 0xff, 0xff,
                          0xc0, 0xa8, 0x64, 0x02, 0xff, 0xff, 0xff, 0xff,
                          0xc0, 0xa8, 0x64, 0x03, 0xff, 0xff, 0xff, 0xff,
                          0xc0, 0xa8, 0x64, 0x04, 0xff, 0xff, 0xff, 0xff,
                          0xc0, 0xa8, 0x64, 0x05, 0xff, 0xff, 0xff, 0xff};

    u_char  ip1[12][4] ={0xc0, 0xa8, 0x64, 0x16, 0xff, 0xff, 0xff, 0xff,
                         0xc0, 0xa8, 0x64, 0x11, 0xff, 0xff, 0xff, 0xff,
                         0xc0, 0xa8, 0x64, 0x12, 0xff, 0xff, 0xff, 0xff,
                         0xc0, 0xa8, 0x64, 0x13, 0xff, 0xff, 0xff, 0xff,
                         0xc0, 0xa8, 0x64, 0x14, 0xff, 0xff, 0xff, 0xff,
                         0xc0, 0xa8, 0x64, 0x15, 0xff, 0xff, 0xff, 0xff};

    u_int    data[16] = {htonl(2357538),   htonl(22241),    0,    0,    0,     0,          0,         0,
                         htonl(39888),    htonl(224),    0,    0,    0,     0,       0,          0};
    u_int    data1[16] = {htonl(22966),   htonl(254),    0,    0,    0,     0,          0,         0,
                          htonl(19660),    htonl(119),    0,    0,    0,     0,       0,          0};
    if (ethnum & 0x01)
    {
        client.options = htons(0x0001 | 0x0002);
        memcpy(client.mac, mac, 6);
        memcpy(client.ip, ip, 48);
        memcpy(client.data, data, 16);
    }
    else
    {
        client.options = htons(0x0001 | 0x0002 | 0x0004);
        memcpy(client.mac, mac, 6);
        memcpy(client.ip, ip1, 48);
        memcpy(client.data, data1, 16);
    }
    *logout<< getTime() << "发送客户端状态应答[intf=以太口"<<ethnum<<"信息 len=" <<len <<"]" << endl;
    mempush((char *)&client, len);
}

void CLIENT::send_usb_info_tosvr(int sock, u_char hasUSB)
{
    struct  TCP_USB_INFO
    {
        TCP_HEAD head;
        u_char   hasUSB;
        u_char   pad[3];
    };

    u_short len = sizeof(TCP_USB_INFO);
    TCP_USB_INFO client = { {0x91,0x07, htons(len), htons(0), htons(len - 8)}, hasUSB} ;

    *logout<< getTime() << "发送客户端状态应答[intf=USB信息 len=" <<len <<"]" << endl;
    mempush((char *)&client, len);

}

void CLIENT::send_usb_fileinfo_tosvr(int sock)
{
    struct  TCP_USBFILE_INFO
    {
        TCP_HEAD head;
        u_char   pro[4095 + 1];
    };

    TCP_USBFILE_INFO client ;  //先不做初始化
    u_short len = 4095;
    readfile(TS_CONF.USB_PATH, client.pro, len);
    len += 8;   //加头部长度
    client.head.h1 = 0x91; client.head.h2 = 0x0c;
    client.head.headlen = htons(len);
    client.head.h3 = 0;
    client.head.head_datalen = htons(len - 8);

    *logout<< getTime() << "发送客户端状态应答[intf=USB文件列表信息 len=" <<len <<"]" << endl;
    mempush((char *)&client, len);

}

void CLIENT::send_prinet_info_tosvr(int sock, u_char status)
{
    struct  TCP_PRI_INFO
    {
        TCP_HEAD head;
        u_char   status;
        u_char   pad;
        u_short jobs;
        u_char  name[32];
    };

    u_short len = sizeof(TCP_PRI_INFO);
    TCP_PRI_INFO client = { {0x91,0x08, htons(len), htons(0), htons(len - 8)}, status} ;
    srand(time(0) + getpid());

    if (status & 0x01)
    {
        client.jobs = htons((u_short)rand() % 26);
    }
    get_randstr(client.name, 32);
    *logout<< getTime() << "发送客户端状态应答[intf=打印口信息 len=" <<len <<"]" << endl;
    mempush((char *)&client, len);

}

void CLIENT::send_prinet_list_tosvr(int sock)
{
    struct  TCP_LIST_INFO
    {
        TCP_HEAD head;
        u_char  pad;
    };

    u_short len = sizeof(TCP_LIST_INFO);
    TCP_LIST_INFO client = { {0x91,0x0d, htons(len), htons(0), htons(len - 8)}, '\0'} ;
    *logout<< getTime() << "发送客户端状态应答[intf=打印队列信息 len=" <<len <<"]" << endl;
    mempush((char *)&client, len);

}

void CLIENT::send_tsevser_info_tosvr(int sock, u_char asynum, int &_devnum)
{
    struct  TCP_TSERVER_INFO
    {
        TCP_HEAD head;
        u_char   asterm[16];
        u_char   ipterm[254];
        u_short  devnum;
    };

    u_short len = sizeof(TCP_TSERVER_INFO);
    TCP_TSERVER_INFO client = { {0x91,0x09, htons(len), htons(0), htons(len - 8)}} ;
    srand(time(0) + getpid());

    u_short total = TS_CONF.MIN_DEV_NUM + rand()%(TS_CONF.MAX_DEV_NUM - TS_CONF.MIN_DEV_NUM);
    u_short async_term_num = 0;
    u_short ipterm_num = 0;

    client.devnum = htons(total + rand()%(271 - total));
    memset(client.asterm, 0, 16);
    memset(client.ipterm, 0, 254);

    if (asynum)
    {
        async_term_num = 1 + rand()%(u_int)asynum;
    }

    if (async_term_num > total)        total = async_term_num;
    ipterm_num = total - async_term_num ;

    while(async_term_num)
    {
        short i = rand()%asynum ;
        if (!client.asterm[i])
        {
            client.asterm[i] = 0x01 ;
            --async_term_num;
        }
    }

    while(ipterm_num)
    {
        short i = rand()%254 ;
        if (!client.ipterm[i])
        {
            client.ipterm[i] = 0x01 ;
            --ipterm_num;
        }
    }
    *logout<< getTime() << "发送客户端状态应答[intf=终端服务信息 len=" <<len <<"]" << endl;
    mempush((char *)&client, len);

    //for check
    _devnum += total ;
}

void CLIENT::send_tty_info_tosvr(int sock, int &_scrnum)
{
    struct  TCP_TERM_INFO
    {
        TCP_HEAD head;
        u_char  port;
        u_char  port_conf;
        u_char  cur;
        u_char  scrnum;
        u_char  ip[4];
        u_char  type[12];
        u_char  status[8];
    };

    srand(time(0) + getpid());
    u_char  scrnum = TS_CONF.MIN_TTY_NUM + rand()%(TS_CONF.MAX_TTY_NUM - TS_CONF.MIN_TTY_NUM + 1);
    u_short len = 36;
    u_char  ip[4] = {0xc0, 0xa8, 0x64, 0x14};
    TCP_TERM_INFO client = { {0x91,tcp_head_svr->h2, htons(len + scrnum * 96), tcp_head_svr->h3, htons(len + scrnum * 96 - 8)}} ;

    client.port = ntohs(tcp_head_svr->h3);
    client.port_conf =(client.port == 1)? client.port: 1 + rand()%(client.port-1);
    client.cur = 1 + (u_char)rand()%scrnum;

    //for check
    _scrnum += scrnum ;

    client.scrnum = scrnum ;
    memcpy(client.ip, ip, 4);
    if (tcp_head_svr->h2 == 0x0a)
    {
        memcpy(client.type, "串口终端", 12);
    }
    else
    {
        memcpy(client.type, "IP终端", 12);
    }
    if (rand() % 2)
    {
        memcpy(client.status, "正常", 8);
    }
    else
    {
        memcpy(client.status, "菜单", 8);
    }
    mempush((char *)&client, len);

    struct  SCR_INFO
    {
        u_char  num;
        u_char  pad;
        u_short port;
        u_char  ip[4];
        u_char  protocol[12];
        u_char  status[8];
        u_char  tip[24];
        u_char  type[12];
        u_int   time;
        u_int   bytes[4];
        u_int   ping[3];
    };
    SCR_INFO    scrs[scrnum];
    for (u_char i=0; i<(u_int)scrnum; i++)
    {
        u_char  ip[4] = {0x0a, 0x3c, 0x66, 0xfc} ;
        srand(time(0) + getpid());
        int     k = rand() % 3;
        scrs[i].num = i+1 ;
        scrs[i].port = htons(52335);
        memcpy(scrs[i].ip, ip, 4);
        memcpy(scrs[i].protocol, "专用SSH", 12);
        if (k == 0)
            memcpy(scrs[i].status, "开机", 8);
        else if (k == 1)
            memcpy(scrs[i].status, "关机", 8);
        else
            memcpy(scrs[i].status, "已登录", 8);
        memcpy(scrs[i].tip, "基金开户", 24);
        memcpy(scrs[i].type, "vt220", 12);

        scrs[i].time = htonl((u_int)time(0));
        scrs[i].bytes[0] = htonl((u_int)rand());
        scrs[i].bytes[1] = htonl((u_int)rand());
        scrs[i].bytes[2] = htonl((u_int)rand());
        scrs[i].bytes[3] = htonl((u_int)rand());
        scrs[i].ping[0] = htonl((u_int)rand()%123456);
        scrs[i].ping[1] = htonl((u_int)rand()%123456);
        scrs[i].ping[2] = htonl((u_int)rand()%123456);
    }
    mempush((char *)&scrs, sizeof(scrs));

    if (tcp_head_svr->h2 ^ 0x0a)
    {
        *logout<< getTime() << "发送客户端状态应答[intf=哑终端"<<(u_int)client.port<<"信息 len=" <<len + sizeof(scrs)<<"]" << endl;
    }
    else
    {
        *logout<< getTime() << "发送客户端状态应答[intf=IP终端"<<(u_int)client.port<<"信息 len=" <<len + sizeof(scrs)<<"]" << endl;
    }
}

std::string CLIENT::getTime()
{
    char base_time[64] ;
    tm *newtime;
    time_t timet;
    time(&timet);
    newtime = localtime(&timet);
    strftime(base_time, 64, "[%y-%m-%d %H:%M:%S] ", newtime);
    return string(base_time);
}

int    CLIENT::socketInit()
{
    if (TS_CONF.DEBUG[0] == '1')    *logout <<getTime()<< "客户端初始化..." << endl;
    //创建套接字
    clientfd = socket(AF_INET, SOCK_STREAM, 0);
    if(clientfd < 0)
    {
        if (TS_CONF.DEBUG[1] == '1')
        {
            *logout << getTime() << "客户端初始化失败" << endl;
        }
        return 0;
    }

    struct sockaddr_in addrSrv;
    memset(&addrSrv, 0, sizeof(addrSrv));
    addrSrv.sin_family = AF_INET;
    addrSrv.sin_port = htons(TS_CONF.PORT);
    addrSrv.sin_addr.s_addr = inet_addr(TS_CONF.IP);

    /* 设为非阻塞模式 */
    int val;
    if ((val = fcntl(clientfd, F_GETFL, 0))<0) {
        close(clientfd);
        return 0;
    }
    if (fcntl(clientfd, F_SETFL, val|O_NONBLOCK)<0) {
        close(clientfd);
        return 0;
    }
    if (TS_CONF.DEBUG[0] == '1')    *logout << getTime()<< "客户端初始化成功" << endl;
    if (TS_CONF.DEBUG[0] == '1')    *logout << getTime()<< "尝试连接至服务器..." << endl;
    if (connect(clientfd, (struct sockaddr *)&addrSrv, sizeof(struct sockaddr)) < 0)
    {
        fd_set  wfd;
        FD_ZERO(&wfd);
        FD_SET(clientfd, &wfd);
        if (select(clientfd+1, NULL, &wfd, NULL, NULL) < 0)
        {
            if (TS_CONF.DEBUG[1] == '1')
                *logout << "连接时出现错误，传输停止" << endl;
            return 0;
        }
        if (TS_CONF.DEBUG[0] == '1')    *logout << getTime()<< "成功连接至服务器" << endl;
        return 1;
    }
}

void    CLIENT::mempush(char *src, int srclen)
{
    if (sender.len + srclen > MAX_SEND_BYTES)
    {
        tcp_send(clientfd, sender.buffer, sender.len);
        memset(sender.buffer, 0, sender.len);
        sender.len = 0;
    }
    memcpy(sender.buffer + sender.len, src, srclen);
    sender.len += srclen ;
}
